---
tags: программирование/структура_данных/список/линейный_список
date: 2022-04-13~~20:53:48
citation: OneNote/Структуры_и_Алгоритмы_Обработки_Данных/Лекция-№5
---
Двусвязный список — подвид [[Связный (связанный) список (линейный список)|линейного списка]], внутри элементов которого хранится ровно два указателя на два иных элемента.
%%^определение%%

## Визуальное представление:
![[Pasted image 20220413223917.png]]
%%^визуальное_представление%%

## Реализация односвязного списка в программе:
Вместо типа int для самих данных могут быть любые типы данных (даже другие структуры и списки).
### C++
```cpp
struct Elem
{
	int info; // информационное поле звена
	Elem *next; // указатель на следующее звено
	Elem *prev; // указатель на предыдущее звено
};
Elem *list_head = NULL, // указатель на начало
*list_tail = NULL; // указатель на конец
```

## Сравнение с [[Односвязный Список|односвязным списком]]:
Преимущества:
* Эффективное перемещение по списку как из начала списка так и с конца;
* Быстрое определение предшествующего и последующего элементов для заданного;
* Отпадает необходимость во вспомогательных указателях предыдущего узла для удаления элементов.
%%^преимущества_перед_односвязным_списком%%

Недостатки:
* Требуется дополнительная память для двух указателей в каждом элементе двусвязного списка.
%%^недостатки_в_сравнении_с_односвязным_списком%%

## Сравнение с [[Последовательный Список|последовательным списком]]:
Преимущества:
* Вставка нового элемента не требует перемещение всех последующих;
* Удаление элемента не требует перемещение всех последующих.
%%^преимущества_перед_последовательным_списком%%

Недостатки:
* Требуется дополнительная память под $(n+1)\cdot 2$ указатель для списка длиной $n$;
* Долгий последовательный доступ к серединным элементам как из начала, так и с конца;
%%^недостатки_в_сравнении_с_последовательным_списком%%

## Реализация операций над односвязным списком в программе:

### Функция вставки элемента в начало списка:
Визуальное представление:
![[Pasted image 20220413230501.png]]
%%^вставка_в_начало_алгоритм%%
#### C++
```cpp
void InsertHead(Elem **head, Elem **tail, int ins)
{
	Elem *ins_node = new Elem;
	ins_node->info = ins;
	if (*head == NULL && *tail == NULL) // пустой список
	{
		ins_node->next = NULL;
		ins_node->prev = NULL;
		*head = ins_node;
		*tail = ins_node;
	}
	else // см рисунок выше
	{
		ins_node->next = *head;
		ins_node->next->prev = ins_node;
		ins_node->prev = NULL;
		*head = ins_node;
	}
}
```
%%^C++операция_вставки_в_начало%%

### Функция удаления элемента (где угодно):
Использует меньше памяти по сравнению с односвязным списком.
%%^удаление_преимущество%%
Визуальное представление:
![[Pasted image 20220413230807.png]]
%%^удаление_где_угодно_алгоритм%%

#### C++
```cpp
void Delete(Elem **head, Elem **tail, Elem *delete_pos)
{
	if(delete_pos)
	{
		if(delete_pos->prev == NULL && delete_pos->next != NULL) // первый но не последний
		{
			delete_pos->next->prev = NULL;
			*head = delete_pos->next;
		}
		else if(delete_pos->prev != NULL && delete_pos->next != NULL) // последний, но не первый
		{
			delete_pos->prev->next = NULL;
			*tail = delete_pos->prev;
		}
		else if(delete_pos->prev == NULL && delete_pos->next == NULL) // единственный узел
		{
			*head = NULL;
			*tail = NULL;
		}
		else // середина списка, как на рисунке
		{
			delete_pos->prev->next = delete_pos->next;
			delete_pos->next->prev = delete_pos->prev;
		}
	}
	return;
}
```
%%^C++операция_удаления_где_угодно%%

