---
tags: программирование/структура_данных/список/линейный_список
date: 2022-04-13~~20:14:02
citation: OneNote/Структуры_и_Алгоритмы_Обработки_Данных/Лекция-№4
---
Односвязный список — подвид [[Связный (связанный) список (линейный список)|линейного списка]], внутри элементов которого хранится лишь один указатель на следующий элемент.
%%^определение%%

## Визуальное представление:
![[Pasted image 20220413200322.png]]
%%^визуальное_представление%%

## Реализация односвязного списка в программе:
Вместо типа int для самих данных могут быть любые типы данных (даже другие структуры и списки).
#### C++
```cpp
struct Elem // структура для элемента линейного списка
{
	inf info; // информационное поле элемента
	Elem *next; // указатель на следующий элемент
};

int main()
{
	Elem* number_list = NULL; /* Указатель на начало списка, если указатель равен NULL(0, nullptr), то список пустой*/
	//...
	return 0;
}
```
%%^C++реализация%%

## Сравнение с [[Последовательный Список|последовательным списком]]:
Преимущества:
* Вставка нового элемента не требует перемещение всех последующих;
* Удаление элемента не требует перемещение всех последующих.
%%^преимущества_перед_последовательным_списком%%

Недостатки:
* Требуется дополнительная память под $n+1$ указатель для списка длиной $n$;
* Долгий последовательный доступ к любому элементу, путем просмотра всех предыдущих элементов;
* Операции вставки и удаления элемента в конце списка требует большого количества операций (времени).
%%^недостатки_в_сравнении_с_последовательным_списком%%

## Реализация операций над односвязным списком в программе:

### Функция определения, пуст ли список L:

#### C++
```cpp
bool Empty(Elem* L)
{
	return (L==NULL);
}
```
%%^C++проверка_пуст_ли%%

### Функция вставки элемента в начало списка:
Алгоритм и визуальное представление:
![[Pasted image 20220413202224.png]]
%%^вставка_в_начало_алгоритм%%

#### C++
```cpp
Elem* InsertHead(Elem* L, int ins)
{
	Elem *new_node = new Elem;
	new_node->info = ins;
	new_node->next = L;
	return new_node;
}
```
%%^C++операция_вставки_в_начало%%

### Функция вставки в конец списка:
Алгоритм и визуальное представление:
![[Pasted image 20220413202420.png]]
%%^вставка_в_конец_алгоритм%%

Недостаток:
* Длиннее время выполнение по сравнению с [[Массив|массивом]] или [[Последовательный Список|последовательным списком]] (нужно от самого начала по указателям дойти до конца односвязного списка);
Не стоит применять односвязный список если задача требует данную функцию.
%%^вставка_в_конец_недостатки%%

#### C++
```cpp
Elem* InsertTail(Elem* L, int ins)
{
	Elem *new_node = new Elem;
	new_node->info = ins;
	new_node->next = NULL;
	if (!L) // список пустой
		return new_node;
	else
	{
		Elem *cur_node = L;
		while(cur_node->next) // пока не конец списка
			cur_node = cur_node->next;
		cur_node->next = new_node;
		return L;
	}
}
```
%%^C++операция_вставки_в_конец%%

### Функция удаления элемента из списка (из начала):
Алгоритм и визуальное представление:
![[Pasted image 20220413202948.png]]
%%^удаление_из_начала_алгоритм%%

#### C++
```cpp
Elem* DeleteHead(Elem* L)
{
	Elem* temp = L;
	L = L->next;
	delete temp;
	return L;
}
```
%%^C++операция_удаления_из_начала%% ^fbcb68

### Функция удаления последнего элемента списка:

#### C++
```cpp
Elem *DeleteTail(Elem* L)
{
	if(L->next==NULL) // единственный узел в списке
	{
		delete L;
		return NULL;
	}
	else
	{
			// del_node - указатель на удаляемый узел
			// prev_node - указатель на предшествующий узел
		Elem *del_node = L, *prev_node = L;
		while(del_node->next) // пока не конец списка
		{
			prev_node = del_node;
			del_node = del_node->next;
		}
		prev_node->next = NULL;
		delete del_node;
		return L;
	}
}
```
%%^C++операция_удаления_последнего%%

### Функция поиска узла со значением x:
Неэффективен, так как мы проверяем каждый элемент односвязного списка от начала до конца.
%%^поиск_недостатки%%

#### C++
```cpp
Elem* Locate(Elem* L, int key)
{
	while(L)
	{
		if(L->info == key)
			return L;
		L = L->next;	
	}
	return NULL;
}
```
%%^C++операция_поиска%%