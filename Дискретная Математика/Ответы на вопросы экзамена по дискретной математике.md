# Вопросы:
## 1) Множества: определение, способы задания. Основные операции над множествами. Диаграммы Эйлера-Венна.
### Определения, свойства:
* Под множеством $M$ понимается: совокупность некоторых объектов, которые будут называться *элементами* множества $M$.
* Тот факт, что $x$ является элементом множества $M$, будем обозначать через $x \in M$ ($x$ принадлежит $M$)
* Если $x$ не является элементом множества $M$, то будем писать $x \notin M$  ($x$ не принадлежит $M$).
* Элементы множества сами могут являться множествами 
> Множество групп студентов состоит из групп студентов, которые сами в свою очередь состоят из элементов отдельных студентов.
* Множество $A$ называется подмножеством множества $B$ если все элементы множества $A$ принадлежат $B$.
> * Обозначается $A \subseteq B$.
> * $A \subseteq B \leftrightarrow \forall x(x \in A \rightarrow x \in B)$.
### Способы задачи:
* Множество можно задать перечислением принадлежащих ему элементов.
> Если $x_1, x_2, ... , x_n$ - все элементы множества $M$, то будем писать $M = \{x_1, x_2, ..., x_n\}$ 
* Множество можно задань указанием свойств, которым элементы множества должны удовлетворять.
> Пусть имеется свойство $P$, которым могут обладать или не обладать элементы некоторого множества $A$.
	> Тогда множество $M$, состоящее из всех элементов множества $A$, обладающих свойством $P$, будет обозначаться через $M\;=\;\{x \in A \;|\;x\; обладает\; свойством\; P\}$
	> А также $M\;=\;\{x\;|\;x\;обладает\;свойством\;P\}$ Когда из контекста ясно, о каком множестве $A$ идёт речь.
	> Также $M\;=\;\{x\;|\;P(x)\}$ Когда из контекста ясно, о каком множестве $A$ идёт речь.
	> Или $M\;=\;\{x\}_{P(x)}$ Когда из контекста ясно, о каком множестве $A$ идёт речь.
### Основные обозначения числовых множеств:
* $N\;или\;\omega$ - множество натуральных чисел;
* $Z$ - множество целых чисел;
* $Q$ - множество рациональных чисел;
* $R$ - множество вещественных чисел;
* $C$ - множество комплексных чисел.
### Операции на булеане $P(U)$ (универсальное множество) булеан - множество всех подмножеств:
* Если $A, B \in P(U)$, то **пересечение/произведение** $A \cap B$ определяется равенством $A \cap B \rightleftharpoons \{x\;|x\in A\; и \; x \in B\}$;
	* Также обозначается $A \cdot B$.
* Если $A, B \in P(U)$, то **объединение/сумма** $A \cup B$ определяется равенством $A \cup B \rightleftharpoons \{x\;|x\in A\; или \; x \in B\}$;
	* Также обозначается $A + B$.
* Если $A, B \in P(U)$, то **разность** $A\;\backslash\;B$ определяется равенством $A\;\backslash\;B \rightleftharpoons A - B \rightleftharpoons \{x\;|x\in A\; и \; x \notin B\}$;
* Если $A, B \in P(U)$, то **кольцевая сумма/симметрическая разность** $A \oplus B$ определяется равенством $A \oplus B \rightleftharpoons (A\;\backslash\;B)\cup(B\;\backslash\;A)$;
* Множество $\bar{A} \rightleftharpoons U\;\backslash\;A$ - **дополнение** множества $A$ в $U$.
* **Декартово произведение** $A\;\times\;B$ по сути мы каждый элемент множества $A$ соотносим каждому элементу множества $B$.
> $Если\;A = \{x_1,x_2\}\; и\;B = \{y_1,y_2\}\; то\;A \times B = \{(x_1,y_1),(x_1,y_2),(x_2,y_1),(x_2,y_2)\}$
> $Если\;A_1 = A_2 = ... = A_n = A, \; то \; множество \; A_1\times A_2\times ... \times A_n \; называется\;n-й\;декартовой\;степенью\;множества\;A\;и\;обозначается\;A^n$
### Основные свойства операций пересечения, объединения и дополнения:
![[Pasted image 20220119140602.png]]
### Диаграммы Эйлера-Венна - наглядно поясняют отношения между множествами (множества A, B... внутри коробки универсального множества U):
![[Pasted image 20220119140411.png]]
## 2) Отношения. Понятие функции. Сюръекция, инъекция, биекция:
### Отношение:
[[Унарное отношение (Свойство)]]
[[n-Местное отношение]]
По сути n-местное отношение - это некоторое подмножество декартово произведения n множеств, при этом переменные входят в отношение $P$.
При n = 1 - **унарное отношение**, при n = 2 - **бинарное отношение** (соответствие).
> Пример: если $A = \{2,3,4,5,6,7,8\}$, то бинарное отношение $P = \{(x,y)\;|\;x,y \in A,\; x\; делит\; y\;и\;x \leq 3\}$  можно записать в виде $P = \{(2,2), (2,4), (2,6), (2,8), (3,3), (3,6)\}$.
> ООФ в данном случае = $\{2,3\}$
> МЗ в данном случае = $\{2,3,4,6,8\}$
> Композиция похожа на транзитивность, если $(x,z) \in P_1$ и $(z,y)\in P_2$ то $P_1\circ P_2 = (x,z)$.
> ![[Pasted image 20220119143207.png]]
### Функция:
Отношение $f \subseteq A\times B$ функция/отображение из множества $A$ в множество $B$, если $ООФ = A$, $МЗ \subseteq B$ и из $(x,y_1) \in f$, $(x,y_2) \in f$ следует $y_1 = y_2$.
> По сути отношение, которое имеет все $x$ из множества $A$ и из одного и того же $x$ следует лишь один $y$
> Функция называется частичной если $ООФ \subseteq A$ 
### Инъекция:
Функция $f$ называется **разнозначной, инъективной, инъекцией или 1-1 функцией**, если для любых элементов $x_1, x_2 \in \delta _f(ООФ)$ из $x_1 \neq x_2$  следует $f(x_1) \neq f(x_2)$
> каждое особое значение x даёт своё особое значение y, они никогда не пересекаются.
### Сюръекция:
Функция $f:A \rightarrow B$ называется функцией $A$ на $B$ или **сюръективной** функцией (сюръекцией), если $\rho_f = B$.
> МЗ не ограничена, по сути $y$ может быть любым внутри своего числового множества $B$.
### Биекция:
Функция $f$ называется взаимно однозначным соответствием между множествами $A$ и $B$ или **биективной функцией (биекцией)**, если она **инъективна и сюръективна**.
> МЗ не ограничена и для каждого $x$ внутри ООФ $y$ приобретает особое значение.
## 3) Мощность множества. Конечные и бесконечные множества:
* Понятие мощности возникает при сравнении множеств по числу элементов.
* Мощностью множества $A$ называется класс всех множеств, эквивалентных множеству $A$.
	* Если множество $A$ имеет ровно $n \in N$ элементов, то множество $A$ называется **конечным**.
		> пишем $|A| = n$.
	* Если множество не конечное, то его называют **бесконечным**.
	* Если $|A| = N$, то множество $A$ называют **счётным**
	* Если $|A| = 2^N$, то множество $A$ называют **континуальным или континумом**.
## 4) Понятие бинарного отношения. Свойства отношений. Матрица бинарного отношения:
### Бинарное отношение:
* n-местное отношение называется бинарным если n = 2.
	> бинарное отношение - некоторое подмножество декартово произведения двух множеств $A$ и $B$, элементы которых связаны некоторым отношением $P$.
### Матрица бинарного отношения:
* Рассмотрим два конечных множества $A = \{a_1,a_2,...,a_m\},\;B=\{b_1,b_2,...,b_n\}$ и бинарное отношение $P \subseteq A \times B$. Определим матрицу $[P] = (p_{ij})$ размера $m\times n$ бинарного отношения $P$ по следующему правилу:
$$p_{ij} = \Bigg\{\,\begin{array}{rcl}
	1,\;если\;(a_i,b_j)\in P \\
	0,\;если\;(a_i,b_j)\notin P \\
\end{array}$$
* Полученная матрица содержит полную информацию о связях между элементами и позволяет представлять эту информацию на компьютере.
### Свойства отношений:
1) $Если\;P,Q \subseteq A\times B,\;[P] = (p_{ij}),\;[Q]=(q_{ij}),\;то\;[P\cup Q] = (p_{ij}+q_{ij})\;и\;[P\cap Q] = (p_{ij}\cdot q_{ij})$
> Или иными словами **объединение** двух бинарных отношений в матрице представляется суммой соответствующих элементов.
> 
> **Пересечение** двух бинарных отношений в матрице представляется перемножением соответствующих элементов.
2) $Если\; P\subseteq A\times B,\;Q\subseteq B\times C,\;то\;[P\circ Q]=[P]\cdot [Q]$, где умножение матриц $[P]$ и $[Q]$ производится по обычному правилу умножения матриц, но произведение и сумма элементов из $[P]$ и $[Q]$ - по определенным в 1) правилам.
> Иными словами композиция двух бинарных отношений в виде матрицы представляется как перемножение матриц.
3) Матрица обратного отношения $P^{-1}$ равна транспонированной матрице отношения $P:[P^{-1}] = [P]^T$.
4) $Если\; P\subseteq Q,\;[P] = (p_{ij}),\;[Q]=(q_{ij}),\;то\;p_{ij} \leq q_{ij}$.
5) Матрица тождественного отношения $id_A$ единична (главная диагональ единична, остальное - нули).
## 5) Специальные бинарные отношения: отношение эквивалентности и разбиения. Фактор-множества.
### Специальные бинарные отношения:
Пусть $P$ - бинарное отношение на множестве $A:P\subseteq A^2$.
1) Отношение $P$ называется **рефлексивным**, если $(x,x)\in P$ для всех $x\in A$, т.е. $id_A \subseteq P$.
	> Главная диагональ матрицы бинарного отношения вся равна единице.
2) Отношение $P$ называется **симметричным**, если для любых $x,y\in A$ из $(x,y)\in P$ следует $(y,x) \in P$, т.е. $P^{-1} = P$, или $[P]^T = [P]$.
	> Транспонирование матрицы бинарного отношения приводит к тому же бинарному отношению.
3) Отношение $P$ называется **антисимметричным**, если из $(x,y)\in P$ и $(y,x)\in P$ следует, что $x = y$, т.е. $P \cap P^{-1} \subseteq id_A$.
	> При перемножении соответствующих элементов оригинальной бинарной матрицы на транспонированную бинарную матрицу, все элементы остаются нулевыми кроме элементов на главной диагонали (элементы главной диагонали могут быть любыми).
4) Отношение $P$ называется **транзитивным**, если из $(x,y)\in P$ и $(y,z)\in P$ следует $(x,z)\in P$, т.е. $P \circ P \subseteq P$
	> Умножение матрицы бинарного отношения $P$ саму на себя даёт матрицу, содержащееся или равное $P$.
### Отношение эквивалентности:
* Отношение $P$ называется отношением **эквивалентности** (эквивалентностью), если $P$ **рефлексивно, симметрично, транзитивно**
	> Часто обозначают символами $E$ и $\sim$ (тильда): $x\:E\:y$, $x \sim y$.
### Фактор-множество:
Пусть $E$ - эквивалентность на множестве $A$.
* **Классом эквивалентности** элемента $x\in A$ называется множество $E(x) \rightleftharpoons \{y\:|\: x\: E \: y\}$
	> Класс эквивалетности - множество таких $y$ для данного $x$, что между $x$ и $y$ выполняется отношение эквивалентности.
* Тогда множество $A\backslash E \rightleftharpoons \{E(x)|x\in A\}$ называется **фактор-множеством множества $A$ по отношению $E$**.
### Разбиение:
* Множество $A\backslash E$ является разбиением множества $A$.
## 6) Специальные бинарные отношения: отношения частичного и линейного порядка:
[[Дискретная Математика/Теория Множеств/Частичный порядок]]
[[Линейный порядок]]
> Частичный порядок обычно обозначается символом $\leq$, а обратное ему отношение $\leq^{-1}$ - символом $\geq$, отношение $\geq$ также является частичным порядком и называется двойственным порядку $\leq$.

> Отношение $>$ и $<$ соответственно строгие порядки так как не выполняется условие рефлексивности.
## 7) Формулы логики высказываний. Равносильность формул логики высказываний. Таблица истинности.
### Формулы логики высказываний (алгебры логики):
* **Высказыванием** называется повествовательное предложение, о котором в данной ситуации можно сказать, что оно истинно или ложно, но не то и другое одновременно.
* Поставим в соответствие высказыванию $P$ логическую переменную $x$, которая принимает значение $1$, если $P$ истинно, и $0$, если $P$ ложно.
* Пусть $\{x_i\:|\:i \in I\}$ - некоторое множество логических переменных. Определим формулы алгебры логики:
1) Любая логическая переменная является формулой (называемой атомарной);
2) Если $\psi$ и $\varphi$ - формулы, то выражения $\neg\varphi$, $(\varphi \wedge \psi)$, $(\varphi \vee \psi)$, $(\varphi \rightarrow \psi)$, $(\varphi \leftrightarrow \psi)$ являются формулами;
3) Никаких других формул, кроме построенных по пп. 1 и 2, нет.
* Символы $\neg,\;\wedge,\;\vee,\;\rightarrow,\;\leftrightarrow$, использованные в определении, называются логическими операциями или связками и читаются соответственно: **отрицание, конъюнкция, дизъюнкция, импликация и эквивалентность.**
* Также не менее важные логические операции:
	* $(\varphi\:|\:\psi)$ - штрих Шеффера или антиконъюнкция;
	* $(\varphi\:\downarrow\:\psi)$ - стрелка Пирса или антидизъюнкция;
	* $(\varphi\:\oplus\:\psi)$ - кольцевая сумма, логическое сложение или сложение по модулю 2 (анти эквивалентность но официально так не называется);
### Равносильность формул логики высказываний:
* Чтобы избежать обилия скобок приняты соглашения:
	1) Внешние скобки не пишутся. Например, вместо высказывания $((x\vee y)\rightarrow z)$ пишется $(x \vee y) \rightarrow z$;
	2) На множестве $\{\neg,\:\wedge,\:\vee,\:\rightarrow,\:\leftrightarrow,\:|,\:\downarrow,\:\oplus\}$ вводятся транзитивное отношение $<$ "быть более сильным" и отношение эквивалентности $\thicksim$ "быть **равносильным**" по правилам, показанным на следующем рисунке:
	![[Pasted image 20220119220439.png]]
	Согласно этим отношениям недостающие скобки в формуле расставляются последовательно, начиная с наиболее сильных связок и кончая наиболее слабыми, а для равносильных связок расстановка скобок выполняется слева направо.

**Равносильность -  свойство двух функций, одинаковый результат двух формул при одинаковых переменных (одинаковые таблицы истинности).**
### Таблица истинности:
* Действия логических операций задаются **таблицами истинности**, каждой строке которых взаимно однозначно сопоставляется набор значений переменных, составляющих формулу, и соответствующее этому набору значение полученной формулы.
* Таблицы истинности называются также **интерпретациями** логических операций и составляют семантику формул (придание смысла формулам) в отличии от синтаксиса формул (формальных законов их построения, данных в определении формулы).
* Исходя из таблиц истинности для логических операций можно строить таблицы истинности для произвольных формул.
## 8) Понятие булевой функции. Представлении булевой функции формулой логики высказываний. Существенные и несущественные переменные, элементарные функции и их свойства:
### Понятие булевой функции:
* **Функцией алгебры логики (Булевой алгебры; Двоичные функции; Переключательные функции; ФАЛ)** от $n$ переменных $x_1,x_2,...,x_n$ называется любая функция $f:\{0,1\}^n \rightarrow \{0,1\}$, т.е. функция, которая произвольному набору $(\delta_1,\delta_2,...,\delta_n)$ нулей и единиц ставит в соответствие значение $f(\delta_1,\delta_2,...,\delta_n)\in\{0,1\}$;
* Булевой функцией описываются преобразования некоторым устройством входных сигналов в выходные.
### Представление булевой функции формулой логики высказываний:
* Булева функция $f(x_1,x_2,...,x_n)$ полностью определяется своей **таблицей истинности**.
	> В каждой строке таблицы вначале задается набор значений переменных $(\delta_1,\delta_2,...,\delta_n)$, а затем - значение функции на этом наборе.
* Булева функция также однозначно задается **перечислением** всех наборов, на которых она принимает значение $0$, либо **перечислением** всех наборов, на которых она принимает значение $1$.
* **Вектором значений** булевой фукнции $f(x_1,x_2,...,x_n)$ называется упорядоченный набор всех значений функции $f$, при котором значения упорядочены по лексикографическому порядку множества аргументов $\{0,1\}^n$.
* Поскольку всего имеется $2^n$ наборов $(\delta_1,\delta_2,...,\delta_n)$ нулей и единиц, **существует ровно $2^{2^n}$ булевых функций** $f(x_1,x_2,...,x_n)$ **от $n$ переменных.**
* Наборы $\{\delta_1,\delta_2,...,\delta_n\}$ нулей и единиц можно представить в виде вершин n-мерных кубов или в виде вершин 2-дерева (рисунок далее)
 ![[Pasted image 20220120013242.png]]
### Существенные и несущественные переменные:
* Переменная является существенной если изменение его значение с $1$ на $0$ имеет эффект на результат булевой функции.
* Несущественная если не имеет никакого эффекта.
### Элементарные функции и их свойства:
* $\neg\varphi$ - отрицание;
* $(\varphi \wedge \psi)$ - конъюнкция;
* $(\varphi \vee \psi)$ - дизъюнкция;
* $(\varphi \rightarrow \psi)$ - импликация;
* $(\varphi \leftrightarrow \psi)$ - эквивалентность; 
* $(\varphi\:|\:\psi)$ - штрих Шеффера или антиконъюнкция;
* $(\varphi\:\downarrow\:\psi)$ - стрелка Пирса или антидизъюнкция;
* $(\varphi\:\oplus\:\psi)$ - кольцевая сумма, логическое сложение или сложение по модулю 2 (анти эквивалентность но официально так не называется);
Основные эквивалентности между формулами:
1) $((x \wedge y) \wedge z) = (x \wedge (y \wedge z))$ а также $((x \vee y) \vee z) = (x \vee(y\vee z))$ - **ассоциативность** $\wedge$ и $\vee$;
2) $(x\wedge y) = (y \wedge x)$ а также $(x \vee y) = (y \vee x)$ - **коммутативность** $\wedge$ и $\vee$;
3) $(x \wedge x) = x$ а также $(x \vee x) = x$ - **идемпотентность** $\wedge$ и $\vee$;
4) $(x \wedge (y \vee z)) = ((x \wedge y) \vee (x \wedge z))$ а также $(x \vee (y \wedge z)) = ((x \vee y) \wedge (x \vee z))$ - **законы дистрибутивности**;
5) $(x \wedge (x \vee y)) = x$ а также $(x \vee (x \wedge y)) = x$ - **законы поглощения**;
6) $\neg(x \wedge y) = \neg x \vee \neg y$ а также $\neg(x \vee y) = \neg x \wedge \neg y$ - **законы де Моргана**;
7) $\neg\neg x = x$ - **закон двойного отрицания**;
8) $x \rightarrow y = \neg x \vee y$;
9) $x \leftrightarrow y = (x \rightarrow y) \wedge (y \rightarrow x) = (\neg x \vee y) \wedge (x \vee \neg y)$;
10) $(x \vee (\neg x \wedge y)) = (x \vee y)$ а также $(\neg x \vee (x \wedge y)) = (\neg x \vee y)$;
11) $x \wedge (\neg x \vee y) = x \wedge y$ а также $\neg x \wedge (x \vee y) = \neg x \wedge y$.
## 9) СДНФ, СКНФ формул логики высказываний:
* Дизъюнкция конъюнктов называется дизъюнктивной нормальной формой (**ДНФ**).
	> Формула $x\bar{y}\vee yz$ - ДНФ.
* Конъюнкция дизъюнктов называется конъюнктивной нормальной формой (**КНФ**).
	> Формула $(x\vee z\vee\bar{y})(x\vee z)y$ - КНФ.
* Формула $x\bar{y}$ называется одновременно ДНФ и КНФ.
#### Теорема 4.4.1:
1) Любая формула эквивалентна некоторой ДНФ;
2) Любая формула эквивалентна некоторой КНФ.

* Алгоритм приведение формулы к ДНФ:
	1) Выражаем все логические операции, участвующие в построении формулы, через дизъюнкцию, конъюнкцию и отрицания, используя эквивалентности:
		* $x \rightarrow y = \neg x \vee y$;
		* $x \leftrightarrow y = (x \rightarrow y) \wedge (y \rightarrow x) = (\neg x \vee y) \wedge (x \vee \neg y)$;
		* Определения операций $|,\:\downarrow,\:\oplus$.
	2) Используя законы де Моргана, переносим все отрицания к переменным и сокращаем двойные отрицания по правилу $\neg\neg x = x$.
	3) Используя закон дистрибутивности: $(x \wedge (y \vee z)) = ((x \wedge y) \vee (x \wedge z))$, преобразуем формулу так, чтобы все конъюнкции выполнялись раньше дизъюнкций.

* Алгоритм приведения формулы к КНФ (отличается от ДНФ в 3м пункте):
	1) Выражаем все логические операции, участвующие в построении формулы, через дизъюнкцию, конъюнкцию и отрицания, используя эквивалентности:
			* $x \rightarrow y = \neg x \vee y$;
			* $x \leftrightarrow y = (x \rightarrow y) \wedge (y \rightarrow x) = (\neg x \vee y) \wedge (x \vee \neg y)$;
			* Определения операций $|,\:\downarrow,\:\oplus$.
	2) Используя законы де Моргана, переносим все отрицания к переменным и сокращаем двойные отрицания по правилу $\neg\neg x = x$.
	3) Используя закон дистрибутивности: $(x \vee (y \wedge z)) = ((x \vee y) \wedge (x \vee z))$, преобразуем формулу так, чтобы все конъюнкции выполнялись раньше дизъюнкций.

* Любая булева функция может иметь бесконечно много представлений в виде ДНФ и КНФ. Особое место среди этих представлений занимают **совершенные ДНФ (СДНФ) и совершенные КНФ (СКНФ)**.
* Остальное можно из лаб 4,5 вспомнить долго писать.

## 10) Минимализация в классе ДНФ, алгоритм построения сокращенной ДНФ:
4,5 лабы много требовали такого, вспомнишь (строим СДНФ, ярусы, оставшиеся без звёздочек в матрицу квайна, ищем ядра, добавляем чего не хватает, склеиваем).
Новая информация: матрица квайна имеет вид:
![[Pasted image 20220120021340.png]]
* Функция $g$  является **импликантой** $f$ тогда, когда $g(x) \leq f(x)$
* **Конституенты единиц** - элементы СДНФ, которые мы строим из значений переменных на единичных случаях функции $f$.
* **Сокращенная ДНФ может иметь** **лишние импликанты**, удаление которых не меняет таблицы истинности.
* Если из сокращенных ДНФ удалить все лишние импликанты, то получается ДНФ, называемая **тупиковой**.
* Выбор из всех тупиковых форм формы с наименьшим числом вхождений переменных дает **минимальную ДНФ (МДНФ)**.
## 11)Принцип двойственности для булевых функций. Самодвойственные булевы функции:
* Функция $f^+(x_1,...,x_n)$ называется двойственной по отношению к функции $f(x_1,...,x_n)$, если $f^+(x_1,...,x_n) = \overline{f(\overline{x_1},...,\overline{x_n})}$
	>Иными словами, если таблица истинности, перевернутая на 180 градусов и где $0$ заменены на $1$ и наоборот, имеет ту же таблицу истинности.
* Двойственная функция получается из исходной при замене значений всех переменных, а также значений функций на противоположные, т.е. в таблице истинности нужно заменить 0 на 1, а 1 на 0.
* Можно получить булеву функцию двойственной исходной для ДНФ или КНФ  с помощью замены всех $\wedge$ на $\vee$ и наоборот.
	> Например $(xy\wedge\overline{xz}\wedge\bar{x}y\bar{z})^+ = (x \vee y) \wedge (\bar{x}\vee\bar{z})\wedge(\bar{x}\vee y \vee\bar{z})$.
* Если формула $\varphi$ эквивалентна формуле $\psi$: $\varphi \thicksim \psi$, то $\varphi^+ \thicksim \psi^+$.
* Функция $f(x_1,...,x_n)$ называется самодвойственной, если:
$$f^+(x_1,...,x_n) = f(x_1,...,x_n)$$
## 12)Полином Жегалкина (СПНФ). Способы построения. Линейные булевы функции.
### СПНФ, линейность:
* Теорема Жегалкина:
	* Всякая булева фукнция $f(x_1,x_2,...,x_n)$ представима **полиномом Жегалкина**.
	* Представление булеовй функции в виде полинома Жегалкина единственно с точностью до порядка слагаемых.
	* Полином Жегалкина называется **нелинейным (линейным)**, если он (не) содержит произведения переменных.
### Способы построения:
1) Преобразованием, используя формулы с кольцевой суммой.
	1) $1 \oplus x = \bar{x}$;
	2) $x \vee y = x \oplus y \oplus xy$;
	3) $x\thicksim y = \overline{x\oplus y} = x \oplus y \oplus 1$;
	4) $z|y = \overline{zy} = zy\oplus 1$;
	5) $1 \oplus 1 = 0$;
	6) $x \oplus 0 = x$;
	7) $x \rightarrow y = x \oplus xy \oplus 1$;
2) С помощью нахождения коэффициентов $c_i$ используя таблицу истинности (см задания на нахождения СПНФ в лабе 4,5).
## 13)Функционально замкнутые классы. Полные системы булевых функций. Теорема Поста. Базисы:
### Функционально замкнутые классы:
* Функциональная замкнутость класса означает, что с помощью операций из функций, принадлежащих данному классу, можно получить только функции из этого же класса.
	> Иными словами если какая либо функция принадлежит функционально замкнутому классу, и с помощью этой функции построить новые функции, то полученная функция также будет принадлежать всё тому же классу.
### Полные системы булевых функций:
* Система булевых функций $\digamma = \{f_1,f_2,...,f_n\}$ называется полной, если любая булева функция представима в виде терма сигнатуры $\{f_1,f_2,...,f_n\}$, т.е. в виде суперпозиции функций из $\digamma$.
	> Любую булеву функцию можно представить используя $\{f_1,f_2,...,f_n\}$ в качестве символов, как мы можем представить любую функцию используя символы $\{\wedge,\vee,\neg\}$.
### Теорема Поста:
* Система $\digamma$ булевых функций тогда и только тогда является полной, когда для каждого из **Классов Поста** $K_0,K_1,S,M,L$ в системе $\digamma$ найдется функция, не принадлежащая этому классу.
	> В таблице, где строки - функции системы $\digamma$, столбцы - Классы Поста, на столбцах всегда найдётся $-$ (ф-ция строки не приналежит данному Классу Поста).
* **Классы Поста**:
	1) $K_0$ - класс булевых функций, сохраняющих нуль;
		> $f(0,...,0) = 0$;
	2) $K_1$ - класс булевых функций, сохраняющих единицу;
		> $f(1,...,1) = 1$;
	3)  $S$ - класс самодвойственных булевых функций;
		>  Если перевернуть таблицу истинности $f$ и поменять $1$ на $0$ и наоборот, выходит таже самая изначальная таблица истинности;
	4) $M$ - класс монотонных функций:
		> Булева функция называется **монотонной**, если для любых двух наборов нулей и единиц $\{\alpha_1,...,\alpha_n\}$ и $\{\beta_1,...,\beta_n\}$ из условий $\alpha_1 \leq \beta_1,...,\alpha_n \leq \beta_n$ следует $f(\alpha_1,...,\alpha_n) \leq f(\beta_1,...,\beta_n)$
	5) $L$ - класс линейных функций;
		> Булева функция $f(x_1,...,x_n)$ называется **линейной**, если в булевом кольце $\langle \{0,1\};\oplus,\odot\}\rangle$ функция $f$ представима в виде $f(x_1,...,x_n) = c_0 \oplus c_1x_1 \oplus c_2x_2 \oplus ... \oplus c_nx_n$, где $c_0,c_1,...,c_n \in \{0,1\}$.
### Базисы:
* Система булевых функций $\digamma$ называется **базисом**, если она полна, а для люббой функции $f \in \digamma$ система $\digamma \backslash \{f\}$ неполна.
	> Нельзя убрать никакую функцию из базиса, не потеряв при этом его полноты.
* **Теорема**: Каждый базис содержит **не более четырех** булевых функций.
## 14)Логические и релейно-контактные схемы:
### Логические сети:
* Мультиграф $G = \langle M, U, R\rangle$, в котором выделено k вершин (полюсов), называется **k-полюсной сетью**.
* Сеть $G$, задаваемая неориентированным мультиграфом с $k$ полюсами, в которой каждое ребро помечено буквой из алфавита $X = \{x_1,x_2,...,x_n,\overline{x_1},\overline{x_2},...,\overline{x_n}\}$, называется **k-полюсной контактной схемой**. Пример приведен на рисунке далее (два полюса: 2-полюсная сеть, выделены $\alpha_1$ и $\alpha_6$.
![[Pasted image 20220120162603.png]]
* $(k+1)$-полюсная схема, в которой один полюс выделен (он называется входным), а остальные полюса (выходные) равноправны, называется (**1,k)-полюсником**. Получается, если смотреть на 2-полюсную сеть выше, как $\alpha_1$ в качестве входной и $\alpha_6$ в качестве выходной, то его можно назвать (1,1)-полюсником.
* Ребра контактной схемы называются **контактами**.
	* Контакт, соответствующий логической переменной $x_i$, называется **замыкающим**. Замыкающий контакт пропускает ток при $x_i = 1$.
	* Контакт, соответствующий логической переменной $\overline{x_i}$, называется **размыкающим**. Размыкающий контакт пропускает ток при $x_i = 0$.
* Функции $x_i \wedge x_j$ соответствует **последовательное соединение** контактов.
* Функции $x_i \vee x_j$ соответсвует **параллельное соединение** контактов.
* Схеме выше соответствует **электрическая схема (Релейно-контактная схема)** 4.11, а также **схема контактов** 4.12:
![[Pasted image 20220120163434.png]]
* Пусть $a, b$ - полюса контактной схемы $\Sigma$, $[a,b]$ - некоторая цепь из $a$ в $b$, $K_{[a,b]}$ - конъюнкйия литер, приписанных ребрам цепи $[a,b]$.
	* Функция $f_{a,b}(X)$, определяемая формулой $f_{a,b}(X) = \bigvee_{[a,b]}K_{[a,b]}$, в которой дизъюнкция берется по всем простым цепям схемы, соединяющим полюса $a$ и $b$, называется **функцией проводимости** между полюсами $a$ и $b$ схемы $\Sigma$.
	* Говорят, что функция $g(X)$ **реализуется** (1,k)-полюсником, если существует такой выходной полюс $b_i$, что $f_{a_i,b_j}(X) = g(X)$, где $a$ - входной полюс.
* (1,1)-Полюсники называются **эквивалентными**, если они реализуют одну и ту же булеву функцию.
* **Сложность** минимального (1,1)-полюсника, реализующего функцию $f$, называется сложностью функции $f$ (количество вхождений переменных, сложность $xy\vee z$ например $= 3$) в классе (1,1)-полюсников и обозначается через $L_{\pi}(f)$.
* Задача нахождения минимального (1,1)-полюсника по сути сводится к нахождению минимального соответствующего ДНФ, функцию которой реализует (1,1)-полюсник.
### Схемы из функциональных элементов:
* Ориентированная бесконтурная сеть, в которой полюса делятся на входные (входы) и выходные (выходы), называется с**хемой из функциональных элементов**.
* **Входные полюса помечаются символами переменных, а каждая вершина, отличная от входного полюса, - некоторым функциональным символом**. При этом должны выполнятся следующие условия:
	* Если $a$ - входной полюс, то полустепень захода вершины $a$ равна нулю: $deg^-(a)=0$.
	* Если вершина $a$ не является полюсом и помечена n-местным функциональным символом $f$, то $deg^-(a) = n$ и дуги, входящие в $a$ , перенумерованы от $1$ до $n$.
* **Функциональным элементом** называется всякий подмультиграф схемы, состоящий из невходного полюса $a$, помеченного соответствующим символом $f$, и вершины, из которых исходят дуги в вершину $a$.
Пример (a - схема из функциональных элементов, б - функциональный элемент, в - устройство, соответствующее функциональному элементу):
![[Pasted image 20220120165645.png]]
## 15)Основные понятия и определения теории графов. Виды и способы задания графов:
Из предыдущих записей:
[[Граф]]
[[Способы задания графов]]
## 16)Смежность, инцидентность, степени вершин, достижимость. Операции над графами:
Из предыдущих записей:
[[Смежность]]
[[Инцидентность]]
[[Степень вершины]]
[[Полустепень исхода]]
[[Полустепень захода]]
[[Граф]] - в разделе операции над графами.
Новая информация:
* **Достижимость** - вершина $b$ называется **достижимой** из вершины $a$, если существует $(a, b)$-путь.
## 17)Маршруты, цепи, циклы. Виды графов. Связность. Разделяющее множество, разрез:
Из предыдущих записей:
[[Цикл в графе]]
[[Граф]] в разделе виды графов
Новая информация:
### Маршруты, цепи, циклы:
* Пусть $G = \langle M; R \rangle$ - граф. Последовательность $$a_1,u_1,a_2,u_2,...,u_n,a_n+1$$, где $a_1,a_2,...,a_n+1 \in M$, $u_1,u_2,...,u_n \in R$, называется **маршрутом**, соединяющим вершины $a_1$ и $a_{n+1}$ (**($a_1,a_{n+1}$)-маршрутом)**, если $u_i = (a_i,a_{i+1}), i=1,2,...,n$.
* Число $n$ дуг в маршруте называется его **длиной**.
	> По сути это любая последовательность ребёр или вершин, ребра могут повторяться, вершины могут повторяться.
* Если все ребра в маршруте различны, маршрут называется также **цепью**.
* Цепь называется **простой цепью**, если все вершины, кроме первой и последней, различны.
* Маршрут называется **циклическим**, если $a_1 = a_{n+1}$.
* Циклическая цепь называется **циклом**, а циклическая простая цепь, **простым циклом**.
* Неорграф (неориентированный граф) без циклов называется **ациклическим**.
* Минимальная из длин циклов неографа называется его **обхватом**.
* Маршрут называется **путём**, если все его дуги различны (вершины могут повторяться)
* Путь называется **контуром**, если $a_1 = a_{n+1}$
* Граф, не имеющий контуров, называется **бесконтурным**.
### Связность:
* Неорграф называется **связным**, если любые его несовпадающие вершины соединены маршрутом.
* Граф $G$ называется **связным**, если соответствующий ему неорграф $F(G)$ тоже является связным.
* Граф $G$ называется **сильно связным**, если для каждой пары различных вершин $a$ и $b$ существуют $(a,b)-маршрут$ и ($b,a)-маршрут$.
* **Любой связный неограф является сильно связным.**
* Всякий максимальный по включению (сильно) связный подграф данного графа называется его **(сильной) связной компонентой или (сильной) компонентой связности**.
* Теорема: Любой граф представляется в виде объединения непересекающихся связных (сильных) компонент. Разложение графа на связные (сильные) компоненты определяется однозначно.
### Разделяющее множество, разрез:
* **Разделяющим множеством** графа $G = \langle M;R\rangle$ называется множество ребер, при удалении которых число компонент связности графа увеличивается.
* **Разрезом** в графе $G = \langle M; R\rangle$ называется разделяющее множество, в котором нет лишних ребер, то есть минимальное разделяющее множество.
## 18)Метрические характеристики: радиус, диаметр, центр графа:
* **Метрическими (или числовыми) характеристиками** называют параметры графа, определяемые через кратчайшие расстояния между вершинами: центр, радиус и диаметр.
* **Диаметр** определяется как самое длинное из всех кратчайших расстояний между вершинами графа.
* **Центр** определяется как вершина, максимальное расстояние от которой до всех остальных вершин графа минимально.
* **Радиус** - максимальное расстояние от центра до остальных вершин графа.
## 19)Изоморфизм графов:
Из прошлых записей:
[[Изоморфизм]]
[[Изоморфные графы]]
Новая информация:
* Графы $G = \langle V, U \rangle\;и\;G' = \langle V',U'\rangle$ **изоморфны**, если существует такое взаимно однозначное соответствие между множествами их вершин $V$ и $V'$, что вершины соединены ребрами в одном из графов в том и только том случае, когда соответствующие им вершины соединены в другом графе.
* Если ребра ориентированы, то и их **направления также должны соответствовать друг другу**.
## 20)Деревья. Остовные деревья графа:
* Граф $G$ называется **деревом**, если он связный и не имеет циклов.
* **Лесом** называют граф, связные компоненты которого являются деревьями.
	* В частности, **дерево не может иметь петель и кратных ребер**.
* **Остовное дерево** - это дерево, содержащее все вершины графа и некоторые его дуги.
## 21)Поиск в ширину и глубину. Нахождение кратчайшего пути в орграфе:
### Поиск в глубину:
* **Глубинное остовное дерево** - это остовное дерево, полученное при обходе графа в глубину.
	* Данный обход начинается в вершине start и заключается в последовательном включении вершин и ребер графа в дерево, если их еще там нет.
	* При этом следующий сын вершины посещается лишь тогда, когда посещены все вершины, достижимые из предыдущего сына вершины.
> Иными словами, начинаем с вершины start:
	> Отметили эту вершину как посещенной (заносим в массив вершин, изображение как хотите)
	> Идём к следующей не посещенной вершине, смежной с только что посещённой (если не посещенных несколько, переходим к той, у которой наименьший индекс)
		> Если таковых нет, переходим к предку и снова ищем не посещенные.
	> Продолжаем пока все вершины не были посещены.
### Поиск в ширину:
* Поиск в ширину:
	* При поиске в ширину, после посещения первой вершины, посещаются все соседние с ней вершины.
	* Потом посещаются все вершины, находящиеся на расстоянии двух ребер от начальной.
	* При каждом новом шаге посещаются вершины, расстояние от которых до начальной на единицу больше предыдущего.
> Иными словами, начинаем с вершины start:
	> Отмечаем все смежные вершины как посещенные (заносим в массив, на изображение как хотите)
	> Далее переходим к этим вершинам и для них делаем тоже самое, если смежные им вершины не были посещены, отмечаем как посещенные и к ним преходим после того, как мы пройдем через всё текущее поколение.
	> Продолжаем пока все вершины не были посещены.
### Нахождение кратчайшего пути в орграфе
* Аглоритм Дейкстры - позволяет найти кратчайшие пути от данной вершины до всех остальных вершин в графе:
Его вид:
![[Pasted image 20220120180309.png]]
Начало: заносим все расстояния до смежных изначальной вершине вершин
Шаг 1: вершину с наименьшим расстоянием заносим в массив к нашему изначальному
Далее находим пути снова, либо предыдущее расстояние либо "расстояние от 1 до 3 до нужного" (занесенный минимум плюс расстояние до нужного), в зависимости от того, какой из них наименьший.
Шаг 2: снова выбрали наименьший, ищем новые расстояния, rince and repeat.
## 22)Эйлеровы графы. Критерий существования эйлерова цикла:
* **Эйлеров граф** - это граф, в котором существует цикл, содержащий все рёбра графа по одному разу (вершины могут повторяться).
* Если снять ограничение на замкнутость цепи, то граф назыается **полуэйлеровым.**
* **Эйлеров путь (эйлерова цепь)** в графе - это путь, проходящий по всем рёбрам графа и притом только по одному разу (вершины могут повторяться).
* В ориентированном графе под эйлеровым путем (циклом) понимают ориентированный путь (контур), проходящий через все ребра графа.
### Критерии существования эйлерова цикла:
**Теорема 6**: Эйлеров путь в связном графе существует тогда и только тогда, когда в нем имеется не более двух вершин с нечетными степенями.
**Теорема 7:** Эйлеров цикл в связном орграфе существует тогда и только тогда, когда у каждой его вершины число входящих в нее ребер равно числу выходящих (полустепень захода = полустепень исхода; или $deg^+(a_i) = deg^-(a_i)\;\;\; i\in\{1,...,n\}$)
## 23)Гамильтоновы графы. Гамильтонов цикл и его свойства:
* Граф называется гамильтоновым, если он содержит гамильтонов цикл.
* Любой гамильтонов граф также и полугамильтонов.
* **Гамильтоновым путем (циклом)** графа называется путь-цепь (цикл-контур), проходящий через каждую его вершину только один раз (ребра не могут быть пройдены несколько раз, так как они во второй раз всегда приведут к пройденной вершине).
* **Всякий полный граф является гамильтоновым.**
![[Pasted image 20220120224816.png]]
* Если гамильтонов граф объединить с ещё одной вершиной ребром так, что образуется висячая вершина, то **такой граф гамильтоновым не является**.
![[Pasted image 20220120224832.png]]
* **Не является гамильтоновым и граф, представляющий собой простой цикл с "перекладиной"**, на которой расположены одна или несколько вершин.
	> Так как полугамильтонов путь не обязывает вернуться в изначальную вершин
## 24)Алгоритмы построения остовного дерева минимального веса:
* Понятие остова для орграфа $G$ определяется как часть $G'$ графа $G$, для которой $F(G')$ является остовом графа $F(G)$.
* Аналогично вводится понятие остовного дерева для связного орграфа $G$.
### Алгоритмы:
1) **Алгоритм Прима** (рисуем ребра вместе с вершинами):
	* В алгоритме Прима, на каждом шаге рассматривается частичное решение задачи, представляющее собой дерево.
	* В начале это дерево состоит из единственной вершины, в качестве которой может быть выбрана любая вершина графа.
	* Затем к дереву последовательно добавляются ребра и вершины, пока не получится остовное дерево, т.е. каркас.
	* Для того чтобы из текущего дерева при добавлении нового ребра опять получилось дерево, это новое ребро должно соединять вершину дерева с вершиной, еще не принадлежащей дереву.
	* Такие ребра будем называть подходящими относительно рассматриваемого дерева.
	* В алгоритме Прима применяется следующее правило выбора: на каждом шаге из всех подходящих ребер выбирается ребро наименьшего веса.
	* Это ребро вместе с одной вершиной добавляется к дереву.
2) **Алгоритм Дейкстры** см вопрос 21, там он тоже был:
	* ![[Pasted image 20220120225307.png]]
	* Алгоритм Дейкстры очень похож на алгоритм Прима, в нем процесс построения дерева тоже начинается с одной вершины, только в алгоритме Прима это могла быть любая вершина графа, а теперь это должна быть вершина $a$.
	* В дальнейшем на каждом шаге к дереву присоединяется одно новое ребро (и одна вершина).
	* Это ребро выбирается из подходящих ребер, причем понятие подходящего ребра здесь такое же - это ребро, соединяющее вершину дерева с вершиной, ему не принадлежащей. 
	* И правило выбора добавляемого ребра такое же - среди подходящих ребер выбирается ребро наименьшего веса. 
	* Разница в том, что в алгоритме Прима веса ребер заданы изначально, а в алгоритме Дейкстры они вычисляются (находим минимальный из предыдущего минимала или нового пути при добавлении новой вершины).
3) **Алгоритм Краскала** (рисуем с минимального веса рёбра не создавая циклов):
	* В нем тоже на каждом шаге рассматривается частичное решение.
	* Отличие от алгоритма Прима состоит в том, что в алгоритме Краскала частичное решение всегда представляет собой остовный лес $F$ графа $G$.
			> Лес, состоящий из всех вершин графа $G$ и некоторых его ребер.
	* В начале $F$ не содержит ни одного ребра, т.е. состоит из изолированных вершин.
	* Затем к нему последовательно добавляются ребра, пока не будет построен каркас графа $G$.
	* Пусть $F$ - лес, построенный к очередному шагу. Новое ребро можно добавить к этому лесу так, чтобы он остался лесом, только если оно соединяет вершины из разных компонент связности леса $F$.
	* Теперь именно такие ребра будем называть подходящими.
## 25)Минимальный путь в нагруженных графах:
* Отличие алгоритма Форда-Беллмана отличается от алгоритма Дейкстры тем, что Дейкстра не работает в случае, когда дуга может иметь отрицательный вес, Форд-Беллман это учитывает:
* **Алгоритм Форда-Беллмана:**
	* [https://youtu.be/950mtbENLVU](https://vk.com/away.php?utf=1&to=https%3A%2F%2Fyoutu.be%2F950mtbENLVU)
Начинается интересное с 3:55
![[Pasted image 20220120235652.png]]
> Строки - количество использованных ребер, максимальное количество ребер будет всегда не больше количества вершин, так как если количество ребер больше количества вершин, то на этом пути есть цикл, а циклы нам не нужны, они либо добавляют ненужную сумму, либо ничего, либо делают задачу бессмысленной отрицательным результатом
> Стрелки показывают откуда как пришли.
> Двигаемся вниз по строкам выбирая минимумы.
![[Pasted image 20220120235934.png]] 
Выше ещё один пример но перевернут горизонтально, начинаем из вершины $v_2$
## 26)Понятие сети. Потоки на сетях. Алгоритм построения полного потока:
* **Сетью** называется связный орграф $G = \langle M; R \rangle$ без петель.
* Функция $Z$, также сопоставляет какое-то число каждой дуге, его **пропускную способность**.
* В сети также выделяют **начальную вершину**, (полустепень захода $deg^+ = 0$), и **конечную вершину** (полустепень исхода $deg^-=0$).
* **Потоком** в сети $G$ называется функция $f: R \rightarrow Z$, которая ставит в соответствие дуге некоторое число - тот самый поток, который должен быть обязательно меньше либо равно пропускной способности дуги.
* Алгоритм построения полного потока:
	1) Находим ненасыщенный путь  $\mu$ из начальной вершины в конечную, если такого пути нет, то полный поток уже построен.
	2) Такой путь найден.
		1) Строим новый поток: $$\varphi(e) = \Bigg\{\,\begin{array}{rcl}
	\varphi(e) + 1,\;e \in \mu\\
	\varphi(e),\;e\notin \mu\\
\end{array}$$
	2) $\varphi = \varphi + 1$ - суммарный поток
## 27)Орграф приращений. Алгоритм построения максимального потока транспортной сети.
* **Орграф приращений** имеет в два раза больше дуг, чем исходная транспортная сеть.
* Для дуги прямой направленности вес равен $0$, если дуга не является насыщенной, $\infty$ - в противном случае.
* Для дуги обратной направленности вес равен $0$, если поток по ней не равен нулю, $\infty$ - в противном случае.
* **Теорема Форда-Фалкерсона**:
	* Величина максимального потока в сети совпадает с величиной пропускной способности минимального разреза.
* **Алгоритм Форда-Фалкерсона**:
	1) Обнуляем все потоки. Остаточная сеть изначально совпадает с исходной сетью.
	2) В остаточной сети находим любой путь из источника в сток. Если такого пути нет, останавливаемся.
	3) Пускаем через найденный путь (он называется увеличивающим путём или увеличивающей цепью) максимально возможный поток:
		1) На найденном пути в остаточной сети ищем ребро с минимальной пропускной способностью $c_{min}$.
		2) Для каждого ребра на найденном пути увеличиваем поток на $c_{min}$, а в противоположном ему - уменьшаем на $c_{min}$.
		3) Модифицируем остаточную сеть. Для всех ребер на найденном пути, а также для противоположных им ребёр, вычисляем новую пропускную способность. Если она стала ненулевой, добавляем ребро к остаточной сети, а если обнулилась, стираем его.
	4) Возвращаемся на шаг $2$.
## 28)Понятие алгоритма:
* Под алгоритмом обычно понимается точное предписание, определяющее процесс переработки исходных данных в требуемый результат.
* При этом требуется:
	* Чтобы исходные данные были заданы в конкретном алфавите и могли принимать значения из некоторого множества, т.е. носили **массовый характер**;
	* Чтобы процесс переработки данных состоял из отдельных **дискретных** шагов и был **детерминированным**.
	* Чтобы были четко указаны условия остановки процесса, и что следует считать результатом процесса (**конечность**). 
* Математическая модель - **Машина Тьюринга** - является уточнением понятия алгоритма.
## 29)Описание и примеры машин Тьюринга:
* Модель алгоритма, называемая машиной Тьюринга, состоит из бесконечной ленты ($БЛ$), разделенной на ячейки, и управляющей головки ($УГ$), которая перемещается по ленте и способна считывать символ в ячейке, против которой она находится, а также замещать обозреваемый символ новым.
* В ячейках $БЛ$ может храниться символ алфавита $A$.
* $УГ$ может находиться на одном из состояний алфавита состояний $Q$.
* Итак, машина Тьюринга есть, по определению, набор $M = (A, Q, П)$, где $A$ - ленточный (внешний) алфавит, $Q$ - алфавит (внутренних) состояний, $П$ - программа.
### Примеры:
![[Pasted image 20220121002316.png]]
![[Pasted image 20220121002330.png]]

