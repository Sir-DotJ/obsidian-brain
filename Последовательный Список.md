---
tags: программирование/структура_данных/список
date: 2022-04-13~~18:54:36
citation: OneNote/Структуры_и_Алгоритмы_Обработки_Данных/Лекция-№3
---
Способ хранения данных с помощью [[Одномерный Массив|одномерного массива]], в котором:
* Элементы располагаются одна за другой в памяти;
* Размер принимает значение от $0$ до $N$, где $N$ - максимальный размер последовательного списка, определенный заранее.
* Размер последовательного списка хранится с помощью создания переменной, определяющей границу списка (элемент на индексе границы может включаться и не включаться в элементы, зависит от реализации).
%%^определение%%

Примером последовательного списка является [[Массив|массив]] любого типа данных (все элементы внутри массива располагаются друг за другом).
Однако в отличие от [[Массив|массива]] элементов, у последовательного списка размер может принимать разные значения во время работы (динамический тип данных).
%%^сравнение_с_массивом%%

## Визуальное представление:
![[Pasted image 20220413191053.png]]
%%^визуальное_представление%%

## Реализация последовательного списка в программе:
Вместо типа int для самих данных могут быть любые типы данных (даже другие структуры и списки).
### C++
```cpp
const int maxlen = 100; // размер массива
struct LIST
{
	int elem[maxlen] // массив элементов списка
	int last; // индекс последнего элемента списка
};
```
%%^C++реализация%%

## Сравнение с [[Односвязный Список|односвязным]] [[Связный (связанный) список (линейный список)|линейным списком]]:
Преимущества:
* Требуется дополнительная память только для хранения индекса последнего элемента;
* Быстрый, прямой доступ по индексу к любому элементу;
* Легкость (быстрота) операции вставки и удаления элемента в конце списка.
%%^преимущества_перед_односвязным_списком%%

Недостатки:
* Вставка нового элемента в начало и середину списка требует перемещение всех последующих;
* Удаление элемента (кроме последнего) требует перемещение других (следующих за удаляемым элементом).
%%^недостатки_в_сравнении_с_односвязным_списком%%

## Реализация операций над последовательным списком в программе:

### Функция вставки нового элемента ins в указанную позицию pos в неполный список L:

#### C++
```cpp
bool Insert(int ins, int pos, LIST *L)
{
	if (pos > L->last+2 || pos < 1) // не корректная позиция
		return false;
	else if (pos < L->last+2) // вставка не в конец списка
	{
		for(int i = L->last; i >= pos-1; i--)
		/*перемещаем на одну позицию вниз, начиная с последнего*/
		L->elem[i+1] = L->elem[i];
	}
	L->last++;
	L->elem[pos-1] = ins;
	return true;
}
```
%%^C++операция_вставки_на_позицию%%

### Функция определения позиции элемента по значению key в списке L:

#### C++
```cpp
int Locate(int key, LIST *L)
{
	for(int i = 0; i <= L->last; i++)
		if (L->elem[i] == key)
			return (++i);
	return (-1);
}
```
%%^C++операция_нахождения%%

### Функция удаления элемента на указанной позиции pos списка L:

#### C++
```cpp
bool Delete(int pos, LIST *L)
{
	if (pos > L->last+1 || pos < 1)
		return false;
	else if (pos < L->last+1) // не последний элемент
	{
		for(int i = pos-1; i < L->last; i++)
		// перемещаем на одну позицию вверх
			L->elem[i] = L->elem[i+1];
	}
	L->last--;
	return true;
}
```
%%^C++операция_удаления%%